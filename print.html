<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>deserr</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">deserr</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center"><img width="280px" title="The deserr logo is a crab similar to Ferris with an ice cream all in place of his body" src="https://raw.githubusercontent.com/meilisearch/deserr/main/assets/deserr.png"></a>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Deserr is a crate for deserializing data, with the ability to return
custom, type-specific errors upon failure. It was also designed with
user-facing APIs in mind and thus provides better defaults than serde for
this use case.</p>
<p>Unlike serde, deserr does not parse the data in its serialization format itself
but offloads the work to other crates. Instead, it deserializes
the already-parsed serialized data into the final type. For example:</p>
<pre><code class="language-rust ignore">// bytes of the serialized value
let s: &amp;str = ".." ;
// parse serialized data using another crate, such as `serde_json`
let json: serde_json::Value = serde_json::from_str(s).unwrap();
// finally deserialize with deserr
let data = T::deserialize_from_value(json.into_value()).unwrap();
// `T` must implement `Deserr`.</code></pre>
<h2 id="why-would-i-use-it"><a class="header" href="#why-would-i-use-it">Why would I use it</a></h2>
<p>The main place where you should use deserr is on your user-facing API,
especially if it's supposed to be read by a human.
Since deserr gives you full control over your error types, you can improve
the quality of your error messages.
Here is a little preview of what you can do with deserr:</p>
<p>Let's say I sent this payload to update my <a href="https://docs.meilisearch.com/reference/api/settings.html#settings">Meilisearch</a> settings:</p>
<pre><code class="language-json">{
  "filterableAttributes": ["doggo.age", "catto.age"],
  "sortableAttributes": ["uploaded_at"],
  "typoTolerance": {
    "minWordSizeForTypos": {
      "oneTypo": 1000, "twoTypo": 80
    },
    "enabled": true
  },
  "displayedAttributes": ["*"],
  "searchableAttributes": ["doggo.name", "catto.name"]
}
</code></pre>
<h4 id="with-serde"><a class="header" href="#with-serde">With serde</a></h4>
<p>With serde, we don't have much customization; this is the typical kind of message we would get in return:</p>
<pre><code class="language-json">{
  "message": "Json deserialize error: invalid value: integer `1000`, expected u8 at line 6 column 21",
  "code": "bad_request",
  "type": "invalid_request",
  "link": "https://docs.meilisearch.com/errors#bad_request"
}
</code></pre>
<h5 id="the-message"><a class="header" href="#the-message">The message</a></h5>
<blockquote>
<p>Json deserialize error: invalid value: integer <code>1000</code>, expected u8 at line 6 column 21</p>
</blockquote>
<ul>
<li>The message uses the word <code>u8</code>, which definitely won't help a user who doesn't know rust or is unfamiliar with types.</li>
<li>The location is provided in terms of lines and columns. While this is generally good, when most of your users
read this message in their terminal, it doesn't actually help much.</li>
</ul>
<h4 id="the-rest-of-the-payload"><a class="header" href="#the-rest-of-the-payload">The rest of the payload</a></h4>
<p>Since serde returned this error, we cannot know what happened or on which field it happened. Thus, the best we
can do is generate a code <code>bad_request</code> that is common for our whole API. We then use this code to generate
a link to our documentation to help our users. But such a generic link does not help our users because it
can be thrown by every single route of Meilisearch.</p>
<h4 id="with-deserr"><a class="header" href="#with-deserr">With deserr</a></h4>
<pre><code class="language-json">{
  "message": "Invalid value at `.typoTolerance.minWordSizeForTypos.oneTypo`: value: `1000` is too large to be deserialized, maximum value authorized is `255`",
  "code": "invalid_settings_typo_tolerance",
  "type": "invalid_request",
  "link": "https://docs.meilisearch.com/errors#invalid-settings-typo-tolerance"
}
</code></pre>
<h5 id="the-message-1"><a class="header" href="#the-message-1">The message</a></h5>
<blockquote>
<p>Invalid value at <code>.typoTolerance.minWordSizeForTypos.oneTypo</code>: value: <code>1000</code> is too large to be deserialized, maximum value authorized is <code>255</code></p>
</blockquote>
<ul>
<li>We get a more human-readable location; <code>.typoTolerance.minWordSizeForTypos.oneTypo</code>. It gives us the faulty field.</li>
<li>We also get a non-confusing and helpful message this time; it explicitly tells us that the maximum value authorized is <code>255</code>.</li>
</ul>
<h5 id="the-rest-of-the-payload-1"><a class="header" href="#the-rest-of-the-payload-1">The rest of the payload</a></h5>
<p>Since deserr called one of our functions in the process, we were able to use a custom error code + link to redirect
our user to the documentation specific to this feature and this field.</p>
<h4 id="more-possibilities-with-deserr-that-were-impossible-with-serde"><a class="header" href="#more-possibilities-with-deserr-that-were-impossible-with-serde">More possibilities with deserr that were impossible with serde</a></h4>
<h5 id="adding-constraints-on-multiples-fields"><a class="header" href="#adding-constraints-on-multiples-fields">Adding constraints on multiples fields</a></h5>
<p>In Meilisearch, there is another constraint on this <code>minWordSizeForTypos</code>, the <code>twoTypo</code> field <strong>must be</strong> greater than
the <code>oneType</code> field.</p>
<p>Serde doesn't provide any feature to do that. You could write your own implementation of <code>Deserialize</code> for the
entire sub-object <code>minWordSizeForTypos</code>, but that's generally hard and wouldn't even let you customize the
error type.
Thus, that's the kind of thing you're going to check by hand in your code later on. This is error-prone and
may bring inconsistencies between most of the deserialization error messages and your error message.</p>
<p>With deserr, we provide attributes that allow you to validate your structure once it's deserialized.</p>
<h5 id="when-a-field-is-missing"><a class="header" href="#when-a-field-is-missing">When a field is missing</a></h5>
<p>It's possible to provide your own function when a field is missing.</p>
<pre><code class="language-rust ignore">pub fn missing_field&lt;E: DeserializeError&gt;(field: &amp;str, location: ValuePointerRef) -&gt; E {
    todo!()
}</code></pre>
<p>At Meilisearch, we use this function to specify a custom error code, but we keep the default error message which is pretty accurate.</p>
<h5 id="when-an-unknown-field-is-encountered"><a class="header" href="#when-an-unknown-field-is-encountered">When an unknown field is encountered</a></h5>
<p>It's possible to provide your own function when a field is missing.</p>
<pre><code class="language-rust ignore">fn unknown_field&lt;E: DeserializeError&gt;(
    field: &amp;str,
    accepted: &amp;[&amp;str],
    location: ValuePointerRef,
) -&gt; E {
    todo!()
}</code></pre>
<p>Here is a few ideas we have or would like to implement at Meilisearch;</p>
<ul>
<li>In the case of a resource you can <code>PUT</code> with some fields, but can't <code>PATCH</code> all its fields. We can throw a special <code>immutable field x</code> error instead of an <code>unknown field x</code>.</li>
<li>Detecting when you use the field name of an alternative; for example, we use <code>q</code> to make a <code>query</code> while some Meilisearch alternatives use <code>query</code>.
We could help our users with a <code>did you mean?</code> message that corrects the field to its proper name in Meilisearch.</li>
<li>Trying to guess what the user was trying to say by computing the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">levenstein distance</a>
between what the user typed and what is accepted to provide a <code>did you mean?</code> message that attempts to correct typos.</li>
</ul>
<h5 id="when-multiple-errors-are-encountered"><a class="header" href="#when-multiple-errors-are-encountered">When multiple errors are encountered</a></h5>
<p>Deserr lets you accumulate multiple errors with its <code>MergeWithError</code> trait while trying to deserialize the value into your type.
This is a good way to improve your user experience by reducing the number of interactions
a user needs to have to fix an invalid payload.</p>
<hr />
<p>The main parts of deserr are:</p>
<ol>
<li><code>Deserr&lt;E&gt;</code> is the main trait for deserialization, unlike Serde, it's very easy to deserialize this trait manually, see the <code>implements_deserr_manually.rs</code> file in our examples directory.</li>
<li><code>IntoValue</code> and <code>Value</code> describes the shape that the parsed serialized data must have</li>
<li><code>DeserializeError</code> is the trait that all deserialization errors must conform to</li>
<li><code>MergeWithError&lt;E&gt;</code> describe how to combine multiple errors together. It allows deserr
to return multiple deserialization errors at once.</li>
<li><code>ValuePointerRef</code> and <code>ValuePointer</code> point to locations within the value. They are
used to locate the origin of an error.</li>
<li><code>deserialize&lt;Ret, Val, E&gt;</code> is the main function to use to deserialize a value.
<ul>
<li><code>Ret</code> is the returned value or the structure you want to deserialize.</li>
<li><code>Val</code> is the value type you want to deserialize from. Currently, only an implementation for <code>serde_json::Value</code> is provided
in this crate, but you could add your own! Feel free to look into our <code>serde_json</code> module.</li>
<li><code>E</code> is the error type that should be used if an error happens during the deserialization.</li>
</ul>
</li>
<li>The <code>Deserr</code> derive proc macro</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<h3 id="implementing-deserialize-for-a-custom-type-with-a-custom-error"><a class="header" href="#implementing-deserialize-for-a-custom-type-with-a-custom-error">Implementing deserialize for a custom type with a custom error</a></h3>
<p>In the following example, we're going to deserialize a structure containing a bunch of fields and
uses a custom error type that accumulates all the errors encountered while deserializing the structure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{deserialize, DeserializeError, Deserr, ErrorKind, errors::JsonError, Value, ValueKind, IntoValue, take_cf_content, MergeWithError, ValuePointerRef, ValuePointer};
use serde_json::json;
use std::str::FromStr;
use std::ops::ControlFlow;
use std::fmt;
use std::convert::Infallible;

/// This is our custom error type. It'll accumulate multiple `JsonError`.
#[derive(Debug)]
struct MyError(Vec&lt;JsonError&gt;);

impl DeserializeError for MyError {
    /// Create a new error with the custom message.
    ///
    /// Return `ControlFlow::Continue` to continue deserializing even though an error was encountered.
    /// We could return `ControlFlow::Break` as well to stop right here.
    fn error&lt;V: IntoValue&gt;(self_: Option&lt;Self&gt;, error: ErrorKind&lt;V&gt;, location: ValuePointerRef) -&gt; ControlFlow&lt;Self, Self&gt; {
        /// The `take_cf_content` return the inner error in a `ControlFlow&lt;E, E&gt;`.
        let error = take_cf_content(JsonError::error(None, error, location));

        let errors = if let Some(MyError(mut errors)) = self_ {
            errors.push(error);
            errors
        } else {
            vec![error]
        };
        ControlFlow::Continue(MyError(errors))
    }
}

/// We have to implements `MergeWithError` between our error type _aaand_ our error type.
impl MergeWithError&lt;MyError&gt; for MyError {
    fn merge(self_: Option&lt;Self&gt;, mut other: MyError, _merge_location: ValuePointerRef) -&gt; ControlFlow&lt;Self, Self&gt; {
        if let Some(MyError(mut errors)) = self_ {
                other.0.append(&amp;mut errors);
        }
        ControlFlow::Continue(other)
    }
}

#[derive(Debug, Deserr, PartialEq, Eq)]
#[deserr(deny_unknown_fields)]
struct Search {
    #[deserr(default = String::new())]
    query: String,
    #[deserr(try_from(&amp;String) = FromStr::from_str -&gt; IndexUidError)]
    index: IndexUid,
    #[deserr(from(String) = From::from)]
    field: Wildcard,
    #[deserr(default)]
    filter: Option&lt;serde_json::Value&gt;,
    // Even though this field is an `Option` it IS mandatory.
    limit: Option&lt;usize&gt;,
    #[deserr(default)]
    offset: usize,
}

/// An `IndexUid` can only be composed of ascii characters.
#[derive(Debug, PartialEq, Eq)]
struct IndexUid(String);
/// If we encounter a non-ascii character this is the error type we're going to throw.
struct IndexUidError(char);

impl FromStr for IndexUid {
    type Err = IndexUidError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        if let Some(c) = s.chars().find(|c| !c.is_ascii()) {
            Err(IndexUidError(c))
        } else {
            Ok(Self(s.to_string()))
        }
    }
}

impl fmt::Display for IndexUidError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "Encountered invalid character: `{}`, only ascii characters are accepted in the index",
            self.0
        )
    }
}

/// We need to define how the `IndexUidError` error is going to be merged with our
/// custom error type.
impl MergeWithError&lt;IndexUidError&gt; for MyError {
    fn merge(self_: Option&lt;Self&gt;, other: IndexUidError, merge_location: ValuePointerRef) -&gt; ControlFlow&lt;Self, Self&gt; {
            // To be consistent with the other error and automatically get the position of the error we re-use the `JsonError`
            // type and simply define ourself as an `Unexpected` error.
        let error = take_cf_content(JsonError::error::&lt;Infallible&gt;(None, ErrorKind::Unexpected { msg: other.to_string() }, merge_location));
        let errors = if let Some(MyError(mut errors)) = self_ {
            errors.push(error);
            errors
        } else {
            vec![error]
        };
        ControlFlow::Continue(MyError(errors))
    }
}

/// A `Wildcard` can either contains a normal value or be a unit wildcard.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(from(String) = From::from)]
enum Wildcard {
    Wildcard,
    Value(String),
}

impl From&lt;String&gt; for Wildcard {
    fn from(s: String) -&gt; Self {
        if s == "*" {
            Wildcard::Wildcard
        } else {
            Wildcard::Value(s)
        }
    }
}

// Here is an example of a typical payload we could deserialize:
let data = deserialize::&lt;Search, _, MyError&gt;(
    json!({ "index": "mieli", "field": "doggo", "filter": ["id = 1", ["catto = jorts"]], "limit": null }),
).unwrap();
assert_eq!(data, Search {
    query: String::new(),
    index: IndexUid(String::from("mieli")),
    field: Wildcard::Value(String::from("doggo")),
    filter: Some(json!(["id = 1", ["catto = jorts"]])),
    limit: None,
    offset: 0,
});

// And here is what happens when everything goes wrong at the same time:
let error = deserialize::&lt;Search, _, MyError&gt;(
    json!({ "query": 12, "index": "mieli üçØ", "field": true, "offset": "üî¢"  }),
).unwrap_err();
// We're going to stringify all the error so it's easier to read
assert_eq!(error.0.into_iter().map(|error| error.to_string()).collect::&lt;Vec&lt;String&gt;&gt;().join("\n"),
"\
Invalid value type at `.query`: expected a string, but found a positive integer: `12`
Invalid value type at `.offset`: expected a positive integer, but found a string: `\"üî¢\"`
Invalid value at `.index`: Encountered invalid character: `üçØ`, only ascii characters are accepted in the index
Invalid value type at `.field`: expected a string, but found a boolean: `true`
Missing field `limit`\
");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">Attributes</a> are used to customize the <code>Deserr</code>
implementations produced by deserr's derive.</p>
<p>There are three categories of attributes:</p>
<ul>
<li><a href="attributes/container.html"><strong>Container attributes</strong></a> ‚Äî apply to a struct or enum declaration.</li>
<li><a href="attributes/variant.html"><strong>Variant attributes</strong></a> ‚Äî apply to a variant of an enum.</li>
<li><a href="attributes/field.html"><strong>Field attributes</strong></a> ‚Äî apply to one field in a struct or in an enum variant.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use deserr::Deserr;
</span><span class="boring">
</span>#[derive(Deserr)]
#[deserr(deny_unknown_fields)]  // &lt;-- this is a container attribute
struct S {
    #[deserr(default)]  // &lt;-- this is a field attribute
    f: i32,
}

#[derive(Deserr)]
#[deserr(rename_all = camelCase)]  // &lt;-- this is also a container attribute
enum E {
    #[deserr(rename = "_deserr")]  // &lt;-- this is a variant attribute
    DeserrIsGreat,
    SerdeIsAwesome
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Note that a single struct, enum, variant, or field may have multiple attributes
on it.</p>
<h2 id="feature-comparison-table-with-serde"><a class="header" href="#feature-comparison-table-with-serde">Feature comparison table with serde</a></h2>
<h4 id="datastructure-support"><a class="header" href="#datastructure-support">Datastructure support</a></h4>
<div class="table-wrapper"><table><thead><tr><th>datastructure</th><th>serde</th><th>deserr</th><th>note</th></tr></thead><tbody>
<tr><td>Struct</td><td>yes</td><td>yes</td><td></td></tr>
<tr><td>Tuple struct</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>Untagged Enum</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>Untagged unit Enum</td><td>yes</td><td>yes</td><td></td></tr>
<tr><td>Tagged Enum</td><td>yes</td><td>yes</td><td></td></tr>
</tbody></table>
</div>
<h4 id="container-attributes"><a class="header" href="#container-attributes">Container attributes</a></h4>
<div class="table-wrapper"><table><thead><tr><th>features</th><th>serde</th><th>deserr</th><th>note</th></tr></thead><tbody>
<tr><td>rename</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>rename_all</td><td>yes</td><td><a href="attributes/container.html#deserrrenameall">yes</a></td><td></td></tr>
<tr><td>deny_unknown_fields</td><td>yes</td><td><a href="attributes/container.html#deserrdenyunknownfields">yes</a></td><td>With deserr you can call a custom function when an unknown field is encountered</td></tr>
<tr><td>tag</td><td>yes</td><td><a href="attributes/container.html#deserrtag">yes</a></td><td></td></tr>
<tr><td>tag+content</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>untagged</td><td>yes</td><td>no</td><td>it's only supported for unit enums</td></tr>
<tr><td>bound</td><td>yes</td><td>no</td><td>Can be emulated with <code>where_predicate</code></td></tr>
<tr><td>default</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>remote</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>transparent</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>from</td><td>yes</td><td><a href="attributes/container.html#deserrfrom">yes</a></td><td></td></tr>
<tr><td>try_from</td><td>yes</td><td><a href="attributes/container.html#deserrtryfrom">yes</a></td><td></td></tr>
<tr><td>into</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>crate</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>validate</td><td>no</td><td><a href="attributes/container.html#deserrvalidate">yes</a></td><td>Allows you to validate the content of struct <strong>after</strong> it has been deserialized</td></tr>
<tr><td>error</td><td>no</td><td><a href="attributes/container.html#deserrerror">yes</a></td><td>Specify the error type that should be used while deserializing this structure</td></tr>
<tr><td>where_predicate</td><td>no</td><td><a href="attributes/container.html#deserrwherepredicate">yes</a></td><td>Let you add where clauses to the generated <code>Deserr</code> implementation</td></tr>
</tbody></table>
</div>
<h4 id="field-attributes"><a class="header" href="#field-attributes">Field attributes</a></h4>
<div class="table-wrapper"><table><thead><tr><th>features</th><th>serde</th><th>deserr</th><th>note</th></tr></thead><tbody>
<tr><td>rename</td><td>yes</td><td><a href="attributes/field.html#deserrrename">yes</a></td><td></td></tr>
<tr><td>alias</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>default</td><td>yes</td><td><a href="attributes/field.html#deserrdefault">yes</a></td><td></td></tr>
<tr><td>flatten</td><td>yes</td><td>no</td><td>serde doesn't support flattening + denying unknown field</td></tr>
<tr><td>skip</td><td>yes</td><td><a href="attributes/field.html#deserrskip">yes</a></td><td></td></tr>
<tr><td>deserialize_with</td><td>yes</td><td>no</td><td>But it's kinda emulated with <code>from</code> and <code>try_from</code></td></tr>
<tr><td>with</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>borrow</td><td>yes</td><td>no</td><td>deserr does not support types with references</td></tr>
<tr><td>bound</td><td>yes</td><td>no</td><td></td></tr>
<tr><td>map</td><td>no</td><td><a href="attributes/field.html#deserrmap">yes</a></td><td>Allows you to map the value <strong>after</strong> it was deserialized</td></tr>
<tr><td>from</td><td>no</td><td><a href="attributes/field.html#deserrfrom">yes</a></td><td>Deserialize this field from an infallible function</td></tr>
<tr><td>try_from</td><td>no</td><td><a href="attributes/field.html#deserrtry_from">yes</a></td><td>Deserialize this field from a fallible function</td></tr>
<tr><td>missing_field_error</td><td>no</td><td><a href="attributes/field.html#deserrmissing_field_error">yes</a></td><td>Allows you to return a custom error if this field is missing</td></tr>
<tr><td>error</td><td>no</td><td><a href="attributes/field.html#deserrerror">yes</a></td><td>Specify the error type that should be used while deserializing this field</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="container-attributes-1"><a class="header" href="#container-attributes-1">Container attributes</a></h1>
<h3 id="deserrrename_all--"><a class="header" href="#deserrrename_all--"><code>#[deserr(rename_all = ...)]</code></a></h3>
<p>Rename all the fields (if this is a struct) or variants (if this is an enum) according to the given case convention.
The possible values are: <code>lowercase</code>, <code>camelCase</code>.</p>
<p>If you need more values please open an issue, it's easy to implement and was simply not implemented because it isn't required for Meilisearch at the moment.</p>
<div class="warning">
<p>Unlike <code>serde</code>, you don't need to put the double-quotes (<code>"</code>) around the name of the case, e.g.: <code>#[deserr(rename_all = camelCase)]</code>.</p>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(rename_all = camelCase)]
struct Search {
    query: String,
    attributes_to_retrieve: Vec&lt;String&gt;,
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "attributesToRetrieve": ["age", "name"] }),
)
.unwrap();
assert_eq!(data, Search {
    query: String::from("doggo"),
    attributes_to_retrieve: vec![String::from("age"), String::from("name")],
});
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrdeny_unknown_fields"><a class="header" href="#deserrdeny_unknown_fields"><code>#[deserr(deny_unknown_fields)]</code></a></h3>
<p>Always error during deserialization when encountering unknown fields.
When this attribute is not present, by default unknown fields are silently ignored.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug)]
#[deserr(deny_unknown_fields)]
struct Search {
    query: String,
}

let err = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "doggo": "bork" }),
)
.unwrap_err();

assert_eq!(err.to_string(), "Unknown field `doggo`: expected one of `query`");
<span class="boring">}</span></code></pre></pre>
<div class="warning">
<p>Unlike <code>serde</code>, with <code>deserr</code> you can specify provide a custom function to handle the error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, ErrorKind, DeserializeError, ValuePointerRef, take_cf_content, errors::JsonError};
use std::convert::Infallible;
use serde_json::json;

#[derive(Deserr, Debug)]
#[deserr(deny_unknown_fields = unknown_fields_search)]
struct Search {
    query: String,
}

fn unknown_fields_search&lt;E: DeserializeError&gt;(
    field: &amp;str,
    accepted: &amp;[&amp;str],
    location: ValuePointerRef,
) -&gt; E {
    // `E::error` returns a `ControlFlow&lt;E, E&gt;`, which returns the error and indicates
    // whether we should keep accumulating errors or not. However, here we simply
    // want to retrieve the error's value. This is what `take_cf_content` does.
    match field {
        "doggo" =&gt; take_cf_content(E::error::&lt;Infallible&gt;(
                None,
                ErrorKind::Unexpected {
                    msg: String::from("can I pet the doggo? uwu")
                },
                location,
            )),
        _ =&gt; take_cf_content(E::error::&lt;Infallible&gt;(
            None,
            deserr::ErrorKind::UnknownKey { key: field, accepted },
            location,
        )),
    }
}

let err = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "doggo": "bork" }),
)
.unwrap_err();

assert_eq!(err.to_string(), "Invalid value: can I pet the doggo? uwu");

let err = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "catto": "jorts" }),
)
.unwrap_err();

assert_eq!(err.to_string(), "Unknown field `catto`: expected one of `query`");
<span class="boring">}</span></code></pre></pre>
</div>
<h3 id="deserrtag"><a class="header" href="#deserrtag"><code>#[deserr(tag)]</code></a></h3>
<p>Externally tag an enum.</p>
<div class="warning">
<p>Deserr does not support internally tagging your enum yet, which means you'll always need to use this attribute if you're deserializing an enum.</p>
</div>
<p>For complete unit enums, deserr can deserialize their value from a string, though.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: Query,
}

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(tag = "type")]
enum Query {
    Single {
        search: String,
    },
    Multi {
        searches: Vec&lt;String&gt;,
    }
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": { "type": "Single", "search": "bork" } }),
)
.unwrap();
assert_eq!(data, Search {
    query: Query::Single {
        search: String::from("bork"),
    },
});
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrfrom"><a class="header" href="#deserrfrom"><code>#[deserr(from)]</code></a></h3>
<p>Deserializing a type from a function instead of a <code>Value</code>.
You need to provide the following information;</p>
<ol>
<li>The input type of the function (here <code>&amp;String</code>)</li>
<li>The path of the function (here, we're simply using the std <code>FromStr</code> implementation)</li>
</ol>
<p>deserr will first try to deserialize the given type using its <code>Deserr&lt;E&gt;</code> implementation.
That means the input type of the <code>from</code> can be complex. Then deserr will call your
function.</p>
<ul>
<li><a href="attributes/container.html#deserrtryfrom">If your function can fail, consider using <code>try_from</code> instead</a></li>
<li><a href="attributes/field.html#deserrfrom">The field attribute may interests you as well</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(from(String) = From::from)]
enum Wildcard {
    Wildcard,
    Value(String),
}

impl From&lt;String&gt; for Wildcard {
    fn from(s: String) -&gt; Self {
        if s == "*" {
            Wildcard::Wildcard
        } else {
            Wildcard::Value(s)
        }
    }
}

let data = deserialize::&lt;Wildcard, _, JsonError&gt;(
    json!("doggo"),
)
.unwrap();
assert_eq!(data, Wildcard::Value(String::from("doggo")));

let data = deserialize::&lt;Wildcard, _, JsonError&gt;(
    json!("*"),
)
.unwrap();
assert_eq!(data, Wildcard::Wildcard);
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrtry_from"><a class="header" href="#deserrtry_from"><code>#[deserr(try_from)]</code></a></h3>
<p>Try deserializing a type from a function instead of a <code>Value</code>.
You need to provide the following information;</p>
<ol>
<li>The input type of the function (here <code>&amp;String</code>)</li>
<li>The path of the function (here, we're simply using the std <code>FromStr</code> implementation)</li>
<li>The error type that this function can return (here <code>AsciiStringError</code>)</li>
</ol>
<p>deserr will first try to deserialize the given type using its <code>Deserr&lt;E&gt;</code> implementation.
That means the input type of the <code>try_from</code> can be complex. Then deserr will call your
function and accumulate the specified error against the error type of the caller.</p>
<ul>
<li><a href="attributes/container.html#deserrfrom">If your function cannot fail, consider using <code>from</code> directly</a></li>
<li><a href="attributes/field.html#deserrtryfrom">The field attribute may interests you as well</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;
use std::str::FromStr;
use std::fmt;

// Notice how the `try_from` allows us to leverage the deserr limitation on tuple struct.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(try_from(&amp;String) = FromStr::from_str -&gt; AsciiStringError)]
struct AsciiString(String);

#[derive(Debug)]
struct AsciiStringError(char);

impl fmt::Display for AsciiStringError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "Encountered invalid character: `{}`, only ascii characters are accepted",
            self.0
        )
    }
}
impl std::error::Error for AsciiStringError {}

impl FromStr for AsciiString {
    type Err = AsciiStringError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        if let Some(c) = s.chars().find(|c| !c.is_ascii()) {
            Err(AsciiStringError(c))
        } else {
            Ok(Self(s.to_string()))
        }
    }
}

let data = deserialize::&lt;AsciiString, _, JsonError&gt;(
    json!("doggo"),
)
.unwrap();
assert_eq!(data, AsciiString(String::from("doggo")));

let error = deserialize::&lt;AsciiString, _, JsonError&gt;(
    json!("üëâüëà"),
)
.unwrap_err();
assert_eq!(error.to_string(), "Invalid value: Encountered invalid character: `üëâ`, only ascii characters are accepted");
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrvalidate"><a class="header" href="#deserrvalidate"><code>#[deserr(validate)]</code></a></h3>
<p>Validate a structure <strong>after</strong> it has been deserialized.
This is typically useful when your validation logic needs to take multiple fields into account.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, ErrorKind, ValuePointerRef, deserialize, errors::JsonError};
use serde_json::json;
use std::convert::Infallible;

// `__Deserr_E` represents the Error returned by the generated `Deserr` implementation.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(validate = validate_range -&gt; __Deserr_E)]
struct Range {
    min: u8,
    max: u8,
}

fn validate_range&lt;E: DeserializeError&gt;(
    range: Range,
    location: ValuePointerRef,
) -&gt; Result&lt;Range, E&gt; {
    if range.min &gt; range.max {
        Err(deserr::take_cf_content(E::error::&lt;Infallible&gt;(
            None,
            ErrorKind::Unexpected {
                msg: format!(
                    "`max` (`{}`) should be greater than `min` (`{}`)",
                    range.max, range.min
                ),
            },
            location,
        )))
    } else {
        Ok(range)
    }
}

let data = deserialize::&lt;Range, _, JsonError&gt;(
    json!({ "min": 2, "max": 4 }),
)
.unwrap();
assert_eq!(data, Range { min: 2, max: 4 });

let error = deserialize::&lt;Range, _, JsonError&gt;(
    json!({ "min": 4, "max": 2 }),
)
.unwrap_err();
assert_eq!(error.to_string(), "Invalid value: `max` (`2`) should be greater than `min` (`4`)");
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrerror"><a class="header" href="#deserrerror"><code>#[deserr(error)]</code></a></h3>
<p>Customize the error type that can be returned when deserializing this structure
instead of keeping it generic.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, ValuePointerRef, ErrorKind, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(error = JsonError)]
struct Search {
    query: String,
    limit: usize,
}

// As we can see, rust is able to infer the error type.
let data = deserialize::&lt;Search, _, _&gt;(
    json!({ "query": "doggo", "limit": 1 }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), limit: 1 });
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrwhere_predicate"><a class="header" href="#deserrwhere_predicate"><code>#[deserr(where_predicate)]</code></a></h3>
<p>Let you add <code>where</code> clauses to the <code>Deserr</code> implementation that deserr will generate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, MergeWithError, deserialize, errors::JsonError};
use serde_json::json;

// Here we can constraint the generic `__Deserr_E` type used by deserr to implements `MergeWithError`.
// Now instead of constraining the final error type it stays generic if it's able to accumulate with
// with a `JsonError`.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(where_predicate = __Deserr_E: MergeWithError&lt;JsonError&gt;, where_predicate = A: Deserr&lt;JsonError&gt;)]
struct Search&lt;A&gt; {
    #[deserr(error = JsonError)]
    query: A,
    limit: usize,
}
<span class="boring">}</span></code></pre></pre>
<p><a href="attributes/field.html#deserrneedspredicate">For simple cases, see also the <code>needs_predicate</code> field attribute.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant-attributes"><a class="header" href="#variant-attributes">Variant attributes</a></h1>
<h3 id="deserrrename--"><a class="header" href="#deserrrename--"><code>#[deserr(rename = "...")]</code></a></h3>
<p>Deserialize this enum variant with the given name instead of its Rust name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
enum Dog {
  #[deserr(rename = "the kef")]
  Kefir,
  Echo,
  Intel
}

let data = deserialize::&lt;Dog, _, JsonError&gt;(
    json!("the kef"),
)
.unwrap();
assert_eq!(data, Dog::Kefir);
<span class="boring">}</span></code></pre></pre>
<p><a href="attributes/field.html#deserrrename">Also available as a field attribute.</a></p>
<h3 id="deserrrename_all---1"><a class="header" href="#deserrrename_all---1"><code>#[deserr(rename_all = ...)]</code></a></h3>
<p>Rename all the variants according to the given case convention.
The possible values are: <code>lowercase</code>, <code>camelCase</code>.</p>
<p>If you need more values please open an issue, it's easy to implement and was simply not implemented because it isn't required for Meilisearch at the moment.</p>
<div class="warning">
<p>Unlike <code>serde</code>, you don't need to put the double-quotes (<code>"</code>) around the name of the case, e.g.: <code>#[deserr(rename_all = camelCase)]</code>.</p>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(rename_all = lowercase)]
enum Pets {
  KefirTheSnob,
  EchoTheFilthyGoblin,
  IntelTheWise,
}

let data = deserialize::&lt;Pets, _, JsonError&gt;(
    json!("echothefilthygoblin"),
)
.unwrap();
assert_eq!(data, Pets::EchoTheFilthyGoblin);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-attributes-1"><a class="header" href="#field-attributes-1">Field attributes</a></h1>
<h3 id="deserrrename---1"><a class="header" href="#deserrrename---1"><code>#[deserr(rename = "...")]</code></a></h3>
<p>Deserialize this field with the given name instead of its Rust name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: String,
    #[deserr(rename = "atr")]
    attributes_to_retrieve: Vec&lt;String&gt;,
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "atr": ["age", "name"] }),
)
.unwrap();
assert_eq!(data, Search {
    query: String::from("doggo"),
    attributes_to_retrieve: vec![String::from("age"), String::from("name")],
});
<span class="boring">}</span></code></pre></pre>
<p><a href="attributes/variant.html#deserrrename">Also available as a variant attribute.</a></p>
<h3 id="deserrfrom-1"><a class="header" href="#deserrfrom-1"><code>#[deserr(from)]</code></a></h3>
<p>Deserializing a type from a function instead of a <code>Value</code>.
You need to provide the following information;</p>
<ol>
<li>The input type of the function (here <code>&amp;String</code>)</li>
<li>The path of the function (here, we're simply using the std <code>FromStr</code> implementation)</li>
</ol>
<p>deserr will first try to deserialize the given type using its <code>Deserr&lt;E&gt;</code> implementation.
That means the input type of the <code>from</code> can be complex. Then deserr will call your
function.</p>
<ul>
<li><a href="attributes/field.html#deserrtryfrom">If your function can fail, consider using <code>try_from</code> instead</a></li>
<li><a href="attributes/container.html#deserrfrom">The container attribute may interests you as well</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(from(String) = From::from)]
enum Wildcard {
    Wildcard,
    Value(String),
}

impl From&lt;String&gt; for Wildcard {
    fn from(s: String) -&gt; Self {
        if s == "*" {
            Wildcard::Wildcard
        } else {
            Wildcard::Value(s)
        }
    }
}

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: String,
    #[deserr(from(String) = From::from)]
    field: Wildcard,
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "field": "catto" }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), field: Wildcard::Value(String::from("catto")) });

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "field": "*" }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), field: Wildcard::Wildcard });
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrtry_from-1"><a class="header" href="#deserrtry_from-1"><code>#[deserr(try_from)]</code></a></h3>
<p>Try deserializing a type from a function instead of a <code>Value</code>.
You need to provide the following information;</p>
<ol>
<li>The input type of the function (here <code>&amp;String</code>)</li>
<li>The path of the function (here, we're simply using the std <code>FromStr</code> implementation)</li>
<li>The error type that this function can return (here <code>ParseIntError</code>)</li>
</ol>
<p>deserr will first try to deserialize the given type using its <code>Deserr&lt;E&gt;</code> implementation.
That means the input type of the <code>try_from</code> can be complex. Then deserr will call your
function and accumulate the specified error against the error type of the caller.</p>
<ul>
<li><a href="attributes/field.html#deserrfrom">If your function cannot fail, consider using <code>from</code> instead</a></li>
<li><a href="attributes/container.html#deserrtryfrom">The container attribute may interests you as well</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;
use std::convert::Infallible;
use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: String,
    #[deserr(try_from(&amp;String) = FromStr::from_str -&gt; ParseIntError)]
    limit: usize,

}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "limit": "12" }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), limit: 12 });

let error = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "limit": 12 }),
)
.unwrap_err();
assert_eq!(error.to_string(), "Invalid value type at `.limit`: expected a string, but found a positive integer: `12`");
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrdefault"><a class="header" href="#deserrdefault"><code>#[deserr(default)]</code></a></h3>
<p>Allows you to specify a default value for a field.</p>
<p>Note that, unlike serde, by default, <code>Option</code> doesn't automatically use this attribute.
Here you need to explicitly define whether your type can get a default value.
This makes it less error-prone and easier to make an optional field mandatory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    #[deserr(default)]
    query: Option&lt;String&gt;,
    #[deserr(default = 20)]
    limit: usize,
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "limit": 4 }),
)
.unwrap();
assert_eq!(data, Search { query: Some(String::from("doggo")), limit: 4 });

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo" }),
)
.unwrap();
assert_eq!(data, Search { query: Some(String::from("doggo")), limit: 20 });
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrskip"><a class="header" href="#deserrskip"><code>#[deserr(skip)]</code></a></h3>
<p>Allows you to skip the deserialization of a field.
It won't show up in the list of fields generated by <code>deny_unknown_fields</code> or in the
<code>UnknownKey</code> variant of the <code>ErrorKind</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: String,
    // A field can be skipped if it implements `Default` or if the `default` attribute is specified.
    #[deserr(skip)]
    hidden: usize,
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo" }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), hidden: 0 });

// if you try to specify the field, it is ignored
let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "hidden": 2 }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), hidden: 0 });

// Here, we're going to see how skip interacts with `deny_unknown_fields`

#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(deny_unknown_fields)]
struct Search2 {
    query: String,
    // A field can be skipped if it implements `Default`.
    #[deserr(skip)]
    hidden: usize,
}

let error = deserialize::&lt;Search2, _, JsonError&gt;(
    json!({ "query": "doggo", "hidden": 1 }),
)
.unwrap_err();
// NOTE: `hidden` isn't in the list of expected fields + `hidden` is effectively considered as a non-existing field.
assert_eq!(error.to_string(), "Unknown field `hidden`: expected one of `query`");
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrmap"><a class="header" href="#deserrmap"><code>#[deserr(map)]</code></a></h3>
<p>Map a field <strong>after</strong> it has been deserialized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    query: String,
    #[deserr(map = add_one)]
    limit: usize,
}

fn add_one(n: usize) -&gt; usize {
    n.saturating_add(1)
}

let data = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "query": "doggo", "limit": 0 }),
)
.unwrap();
assert_eq!(data, Search { query: String::from("doggo"), limit: 1 });

// Let's see how `map` interacts with the `default` attributes.
#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search2 {
    query: String,
    #[deserr(default, map = add_one)]
    limit: usize,
}

let data = deserialize::&lt;Search2, _, JsonError&gt;(
    json!({ "query": "doggo" }),
)
.unwrap();
// As we can see, the `map` attribute is applied AFTER the `default`.
assert_eq!(data, Search2 { query: String::from("doggo"), limit: 1 });
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrmissing_field_error"><a class="header" href="#deserrmissing_field_error"><code>#[deserr(missing_field_error)]</code></a></h3>
<p>Gives you the opportunity to customize the error message if this specific field
is missing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, ValuePointerRef, ErrorKind, deserialize, errors::JsonError};
use serde_json::json;
use std::convert::Infallible;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search {
    #[deserr(missing_field_error = missing_query_field)]
    query: String,
    limit: usize,
}

fn missing_query_field&lt;E: DeserializeError&gt;(_field_name: &amp;str, location: ValuePointerRef) -&gt; E {
    deserr::take_cf_content(E::error::&lt;Infallible&gt;(
        None,
        ErrorKind::Unexpected {
            msg: String::from("I really need the query field, please give it to me uwu"),
        },
        location,
    ))
}

let error = deserialize::&lt;Search, _, JsonError&gt;(
    json!({ "limit": 0 }),
)
.unwrap_err();
assert_eq!(error.to_string(), "Invalid value: I really need the query field, please give it to me uwu");
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrerror-1"><a class="header" href="#deserrerror-1"><code>#[deserr(error)]</code></a></h3>
<p>Customize the error type that can be returned when deserializing this structure
instead of keeping it generic.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, ValuePointerRef, ErrorKind, deserialize, errors::JsonError};
use serde_json::json;

// Since the error returned by the `Search` structure needs to implements `MergeWithError&lt;JsonError&gt;`
// we also need to specify the `error` attribute as a `JsonError`. But as you will see later there are
// other solutions.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(error = JsonError)]
struct Search&lt;A&gt; {
    #[deserr(error = JsonError)]
    query: A,
    limit: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="deserrneeds_predicate"><a class="header" href="#deserrneeds_predicate"><code>#[deserr(needs_predicate)]</code></a></h3>
<p>Automatically adds <code>where_predicate = FieldType: Deserr&lt;ErrType&gt;</code> for each field with this attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, MergeWithError, deserialize, errors::JsonError};
use serde_json::json;

#[derive(Deserr, Debug, PartialEq, Eq)]
struct Search&lt;A&gt; {
    #[deserr(needs_predicate)]
    query: A,
    limit: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>Is strictly equivalent to the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, DeserializeError, MergeWithError, deserialize, errors::JsonError};
use serde_json::json;

// `__Deserr_E` represents the Error returned by the generated `Deserr` implementation.
#[derive(Deserr, Debug, PartialEq, Eq)]
#[deserr(where_predicate = A: Deserr&lt;__Deserr_E&gt;)]
struct Search&lt;A&gt; {
    query: A,
    limit: usize,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-deserialize-manually"><a class="header" href="#implementing-deserialize-manually">Implementing deserialize manually</a></h1>
<p>The <a href="https://docs.rs/deserr/latest/deserr/trait.Deserr.html"><code>Deserr</code></a> trait looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Deserr&lt;E: deserr::DeserializeError&gt;: Sized {
    fn deserialize_from_value&lt;V: deserr::IntoValue&gt;(
        value: deserr::Value&lt;V&gt;,
        location: deserr::ValuePointerRef&lt;'_&gt;,
    ) -&gt; Result&lt;Self, E&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The method's job is to deserialize a value to the concrete type you're implementing this trait on.
It's useful when the derive macro is not powerful enough for you.
Let's go through all of its paratemers:</p>
<ul>
<li><code>E: deserr::DeserializeError</code>: The error type that can be returned while deserializing your type. It can be anything that implements the <a href="https://docs.rs/deserr/latest/deserr/trait.DeserializeError.html"><code>DeserializeError</code></a> trait.</li>
<li><code>value</code> parameter: The value you must deserialize, it's similar to a <code>serde_json::Value</code>.</li>
<li><code>location</code> parameter: A linked list representing the path being explored. Always make sure to update the location correctly otherwise the error messages will be really hard to debug.</li>
</ul>
<p>For example you'll often need to implement the type yourself while working with enums since deserr
only supports unit enums.</p>
<p>One of the most common type you might need while working with json is a type that represents if a value
is <code>Set</code> (specified by the user), <code>NotSet</code> (the field is not present) or <code>Reset</code> (the field is set to <code>null</code>).
Instead of working with an <code>Option&lt;Option&lt;Value&gt;&gt;</code> we may want to introduce the following enum and implement <code>Deserr</code> on it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{DeserializeError, Deserr, IntoValue, Value, ValuePointerRef};

#[derive(Debug, Clone, PartialEq, Eq, Copy)]
pub enum Setting&lt;T&gt; {
    Set(T),
    Reset,
    NotSet,
}

// If the value is missing we're going to rely on its default implementation of `NotSet`.
impl&lt;T&gt; Default for Setting&lt;T&gt; {
    fn default() -&gt; Self {
        Self::NotSet
    }
}

impl&lt;T, E&gt; Deserr&lt;E&gt; for Setting&lt;T&gt;
where
    T: Deserr&lt;E&gt;,
    // We didn't put any constraint on the error type, that means it's up to the caller to decide the type of errors to return
    E: DeserializeError,
{
    fn deserialize_from_value&lt;V: IntoValue&gt;(
        value: Value&lt;V&gt;,
        location: ValuePointerRef&lt;'_&gt;,
    ) -&gt; Result&lt;Self, E&gt; {
        match value {
            deserr::Value::Null =&gt; Ok(Setting::Reset),
            // If the value contains something, we let the inner type deserialize it
            _ =&gt; T::deserialize_from_value(value, location).map(Setting::Set),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors"><a class="header" href="#handling-errors">Handling errors</a></h1>
<p>The main point of deserr is to improve the error message of your user facing API by using one of our already defined error type or by creating your own.</p>
<ul>
<li><a href="error/available.html">Available error type</a></li>
<li><a href="error/custom.html">Defining your own error</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="already-available-error-type"><a class="header" href="#already-available-error-type">Already available error type</a></h1>
<p>Deserr comes with two predefined error type for json and query parameters.</p>
<h3 id="json"><a class="header" href="#json">Json</a></h3>
<p>Json support is made through the <a href="https://docs.rs/deserr/latest/deserr/errors/json/struct.JsonError.html"><code>JsonError</code></a> type.</p>
<h4 id="changes-to-the-error-messages"><a class="header" href="#changes-to-the-error-messages">Changes to the error messages</a></h4>
<p>Here's a non-exhaustive list of some of the changes that are made to the error message compared to <code>serde_json</code>:</p>
<ul>
<li>Instead of providing the bytes indice of the error it provides the path of the error using dot: <code>error.on.field[3]</code>.</li>
<li>Use the word <code>array</code> instead of <code>Sequence</code></li>
<li>Use the word <code>object</code> instead of <code>Map</code></li>
<li>Never talk about rust type like <code>u8</code> and instead use words like number/integer or the bounds of the number directly.</li>
<li>When using the <code>deny_unknown_parameter</code> container attribute deserr will:
<ul>
<li>List all the available fields of the object.</li>
<li>Find and propose the field with the closest name of what was typed with a "did you mean" message.</li>
</ul>
</li>
</ul>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, errors::JsonError};
use serde_json::json;
#[derive(Deserr, Debug)]
#[deserr(deny_unknown_fields, rename_all = camelCase)]
struct Search {
    q: Values,
    filter: u8,
}
#[derive(Deserr, Debug)]
#[deserr(rename_all = camelCase)]
enum Values {
    Q,
    Filter,
}

// The field name is wrong but is close enough of `filter`
let value = json!({ "filler": "doggo" });
let err = deserr::deserialize::&lt;Search, _, JsonError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown field `filler`: did you mean `filter`? expected one of `q`, `filter`");

// The field name isn't close to anything
let value = json!({ "a": "doggo" });
let err = deserr::deserialize::&lt;Search, _, JsonError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown field `a`: expected one of `q`, `filter`");

// Did you mean also works with enum value
let value = json!({ "q": "filler" });
let err = deserr::deserialize::&lt;Search, _, JsonError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown value `filler` at `.q`: did you mean `filter`? expected one of `q`, `filter`");

let value = json!({ "filter": [2] });
let err = deserr::deserialize::&lt;Search, _, JsonError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Invalid value type at `.filter`: expected a positive integer, but found an array: `[2]`");
<span class="boring">}</span></code></pre></pre>
<h3 id="query-parameter"><a class="header" href="#query-parameter">Query Parameter</a></h3>
<p>Query parameter support is made through the <a href="https://docs.rs/deserr/latest/deserr/errors/query_params/struct.QueryParamError.html"><code>QueryParamError</code></a> type.</p>
<h4 id="changes-to-the-error-messages-1"><a class="header" href="#changes-to-the-error-messages-1">Changes to the error messages</a></h4>
<p>Here's a non-exhaustive list of some of the changes that are made to the error message compared to <code>serde_qs</code>:</p>
<ul>
<li>Instead of providing the bytes indice of the error it provides the path of the error using dot: <code>error.on.parameter[3]</code>.</li>
<li>Use the word <code>multiple values</code> instead of <code>Sequence</code></li>
<li>Use the word <code>multiple parameters</code> instead of <code>Map</code></li>
<li>Never talk about rust type like <code>u8</code> and instead use words like number/integer or the bounds of the number directly.</li>
<li>When using the <code>deny_unknown_parameter</code> container attribute deserr will:
<ul>
<li>List all the available parameters of the object.</li>
<li>Find and propose the parameter with the closest name of what was typed with a "did you mean" message.</li>
</ul>
</li>
</ul>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deserr::{Deserr, errors::QueryParamError};
use serde_json::json;
#[derive(Deserr, Debug)]
#[deserr(deny_unknown_fields, rename_all = camelCase)]
struct Search {
    q: Values,
    filter: u8,
}
#[derive(Deserr, Debug)]
#[deserr(rename_all = camelCase)]
enum Values {
    Q,
    Filter,
}

// The field name is wrong but is close enough of `filter`
let value = json!({ "filler": "doggo" });
let err = deserr::deserialize::&lt;Search, _, QueryParamError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown parameter `filler`: did you mean `filter`? expected one of `q`, `filter`");

// The parameter name isn't close to anything
let value = json!({ "a": "doggo" });
let err = deserr::deserialize::&lt;Search, _, QueryParamError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown parameter `a`: expected one of `q`, `filter`");

// Did you mean also works with enum value
let value = json!({ "q": "filler" });
let err = deserr::deserialize::&lt;Search, _, QueryParamError&gt;(value).unwrap_err();
assert_eq!(err.to_string(), "Unknown value `filler` for parameter `q`: did you mean `filter`? expected one of `q`, `filter`");

let value = json!({ "filter": [2] });
let err = deserr::deserialize::&lt;Search, _, QueryParamError&gt;(value).unwrap_err();
// The query parameters are always expecting string in the values
assert_eq!(err.to_string(), "Invalid value type for parameter `filter`: expected a string, but found multiple values");
<span class="boring">}</span></code></pre></pre>
<h3 id="want-another-format"><a class="header" href="#want-another-format">Want another format</a></h3>
<p>Feel free to open an issue or a PR</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-your-own-error"><a class="header" href="#defining-your-own-error">Defining your own error</a></h1>
<p>Defining your own error type comes down to implementing the <a href="https://docs.rs/deserr/latest/deserr/trait.DeserializeError.html"><code>DeserrError</code></a> trait that looks like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait DeserializeError: Sized + deserr::MergeWithError&lt;Self&gt; {
    fn error&lt;V: deserr::IntoValue&gt;(
        self_: Option&lt;Self&gt;,
        error: deserr::ErrorKind&lt;'_, V&gt;,
        location: deserr::ValuePointerRef&lt;'_&gt;,
    ) -&gt; std::ops::ControlFlow&lt;Self, Self&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The method's job is to build your custom error type from an error kind and a location.
deserr will call this method everytime it encounter an error while deserializing the specified payload and your job will be
to craft your own error type from the parameters, and let deserr know if it should continue to explore the payload looking
for more errors or stop immediately.</p>
<ul>
<li><code>_self</code> contains the previous version of your error if you told deserr to accumulate errors.</li>
<li><code>error</code> the error encountered by deserr whil deserializing the value.</li>
<li><code>location</code> the location of the error</li>
<li><a href="https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html"><code>ControlFlow</code></a> is your way to tell deserr to continue accumulating errors or to stop.</li>
</ul>
<p>And you may have noticed that your type must also implements the <a href="https://docs.rs/deserr/latest/deserr/trait.MergeWithError.html"><code>MergeWithError</code></a> trait.
This trait describe error type that can be merged together to return only one final type.
It also gives you the opportunity to tell deserr to stop deserializing the structure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MergeWithError&lt;T&gt;: Sized {
    fn merge(
        self_: Option&lt;Self&gt;,
        other: T,
        merge_location: deserr::ValuePointerRef&lt;'_&gt;,
    ) -&gt; std::ops::ControlFlow&lt;Self, Self&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait also gives you the opportunity to merge <strong>an other</strong> error type with your error type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="but-why"><a class="header" href="#but-why">But why?</a></h2>
<p>At Meilisearch, we wanted to customize the error code we return when we fail
the deserialization of a specific field.
Some error messages were also not clear at all and impossible to edit.</p>
<h2 id="what-about-the-maintenance"><a class="header" href="#what-about-the-maintenance">What about the maintenance?</a></h2>
<p>At Meilisearch we're already using deserr in production; thus, it's well maintained.</p>
<h2 id="where-can-i-see-more-examples-of-usage-of-this-crate"><a class="header" href="#where-can-i-see-more-examples-of-usage-of-this-crate">Where can I see more examples of usage of this crate?</a></h2>
<p>Currently, you can read our examples in the <code>examples</code> directory of this repository.
You can also look at our integration test; each attribute has a simple-to-read test.</p>
<p>And obviously, you can read the code of Meilisearch where deserr is used on all our
routes.</p>
<h2 id="my-question-is-not-listed"><a class="header" href="#my-question-is-not-listed">My question is not listed</a></h2>
<p>Please, if you think there is a bug in this lib or would like a new feature,
open an issue or a discussion.
If you would like to chat more directly with us, you can join us on discord
at https://discord.com/invite/meilisearch and ping @irevoire.</p>
<h2 id="the-logo"><a class="header" href="#the-logo">The logo</a></h2>
<p>The logo was graciously offered and crafted by @irevoire 's sister after a lot of back and forth.
Many thanks to her.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
